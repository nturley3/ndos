Index: include/cpu.h
===================================================================
--- include/cpu.h	(revision 3720)
+++ include/cpu.h	(working copy)
@@ -41,11 +41,10 @@
 
 
 #define CPU_ARCHTYPE_MIXED			0xff
-#define CPU_ARCHTYPE_386SLOW		0x30
-#define CPU_ARCHTYPE_386FAST		0x35
-#define CPU_ARCHTYPE_486OLDSLOW		0x40
-#define CPU_ARCHTYPE_486NEWSLOW		0x45
-#define CPU_ARCHTYPE_PENTIUMSLOW	0x50
+#define CPU_ARCHTYPE_386			0x35
+#define CPU_ARCHTYPE_486OLD			0x40
+#define CPU_ARCHTYPE_486NEW			0x45
+#define CPU_ARCHTYPE_PENTIUM		0x50
 
 /* CPU Cycle Timing */
 extern Bit32s CPU_Cycles;
@@ -88,6 +87,7 @@
 
 extern Bit16u parity_lookup[256];
 
+void CPU_SetCPL(Bitu newcpl);
 bool CPU_LLDT(Bitu selector);
 bool CPU_LTR(Bitu selector);
 void CPU_LIDT(Bitu limit,Bitu base);
@@ -180,6 +180,7 @@
 #define CR0_FPUEMULATION		0x00000004
 #define CR0_TASKSWITCH			0x00000008
 #define CR0_FPUPRESENT			0x00000010
+#define CR0_WRITEPROTECT		0x00010000
 #define CR0_PAGING				0x80000000
 
 
Index: include/paging.h
===================================================================
--- include/paging.h	(revision 3720)
+++ include/paging.h	(working copy)
@@ -80,6 +80,8 @@
 /* Some other functions */
 void PAGING_Enable(bool enabled);
 bool PAGING_Enabled(void);
+void PAGING_SetWP(bool wp);
+void PAGING_SwitchCPL(bool isUser);
 
 Bitu PAGING_GetDirBase(void);
 void PAGING_SetDirBase(Bitu cr3);
@@ -152,6 +154,7 @@
 struct PagingBlock {
 	Bitu			cr3;
 	Bitu			cr2;
+	bool wp;
 	struct {
 		Bitu page;
 		PhysPt addr;
@@ -172,6 +175,18 @@
 		Bitu used;
 		Bit32u entries[PAGING_LINKS];
 	} links;
+	struct {
+		Bitu used;
+		Bit32u entries[PAGING_LINKS];
+	} ur_links;
+	struct {
+		Bitu used;
+		Bit32u entries[PAGING_LINKS];
+	} krw_links;
+	struct {
+		Bitu used;
+		Bit32u entries[PAGING_LINKS];
+	} kr_links; // WP-only
 	Bit32u		firstmb[LINK_START];
 	bool		enabled;
 };
Index: src/ints/ems.cpp
===================================================================
--- src/ints/ems.cpp	(revision 3720)
+++ src/ints/ems.cpp	(working copy)
@@ -951,7 +951,7 @@
 				break;
 			case 0x0c: {	/* VCPI Switch from V86 to Protected Mode */
 				reg_flags&=(~FLAG_IF);
-				cpu.cpl=0;
+				CPU_SetCPL(0);
 
 				/* Read data from ESI (linear address) */
 				Bit32u new_cr3=mem_readd(reg_esi);
@@ -1411,7 +1411,7 @@
 				CPU_Push32(SegValue(cs));
 				CPU_Push32(reg_eip&0xffff);
 				/* Switch to V86-mode */
-				cpu.cpl=0;
+				CPU_SetCPL(0);
 				CPU_IRET(true,0);
 			}
 		}
@@ -1451,7 +1451,7 @@
 			CPU_SET_CRX(3, 0);
 			reg_flags&=(~(FLAG_IOPL|FLAG_VM));
 			CPU_LIDT(0x3ff, 0);
-			cpu.cpl=0;
+			CPU_SetCPL(0);
 		}
 	}
 };
Index: src/cpu/paging.cpp
===================================================================
--- src/cpu/paging.cpp	(revision 3720)
+++ src/cpu/paging.cpp	(working copy)
@@ -30,16 +30,11 @@
 #include "debug.h"
 #include "setup.h"
 
-#define LINK_TOTAL		(64*1024)
-
-#define USERWRITE_PROHIBITED			((cpu.cpl&cpu.mpl)==3)
-
-
 PagingBlock paging;
 
-
+// Pagehandler implementation
 Bitu PageHandler::readb(PhysPt addr) {
-	E_Exit("No byte handler for read from %d",addr);	
+	E_Exit("No byte handler for read from %x",addr);	
 	return 0;
 }
 Bitu PageHandler::readw(PhysPt addr) {
@@ -56,7 +51,7 @@
 }
 
 void PageHandler::writeb(PhysPt addr,Bitu /*val*/) {
-	E_Exit("No byte handler for write to %d",addr);	
+	E_Exit("No byte handler for write to %x",addr);	
 }
 
 void PageHandler::writew(PhysPt addr,Bitu val) {
@@ -134,487 +129,649 @@
 Bitu DEBUG_EnableDebugger(void);
 #endif
 
-bool first=false;
+#define ACCESS_KR  0
+#define ACCESS_KRW 1
+#define ACCESS_UR  2
+#define ACCESS_URW 3
+#define ACCESS_TABLEFAULT 4
+const char* const mtr[] = {"KR ","KRW","UR ","URW","PFL"};
 
-void PAGING_PageFault(PhysPt lin_addr,Bitu page_addr,Bitu faultcode) {
-	/* Save the state of the cpu cores */
-	LazyFlags old_lflags;
-	memcpy(&old_lflags,&lflags,sizeof(LazyFlags));
-	CPU_Decoder * old_cpudecoder;
-	old_cpudecoder=cpudecoder;
-	cpudecoder=&PageFaultCore;
+// bit0 entry write
+// bit1 entry access
+// bit2 table write
+// bit3 table access
+// These arrays define how the access bits in the page table and entry
+// result in access rights.
+// The used array is switched depending on the CPU under emulation.
+
+// Intel says the lowest numeric value wins for both 386 and 486+
+// There's something strange about KR with WP=1 though
+static const Bit8u translate_array[] = {
+	ACCESS_KR,		// 00 00
+	ACCESS_KR,		// 00 01
+	ACCESS_KR,		// 00 10
+	ACCESS_KR,		// 00 11
+	ACCESS_KR,		// 01 00
+	ACCESS_KRW,		// 01 01
+	ACCESS_KR, //	ACCESS_KRW,		// 01 10
+	ACCESS_KRW,		// 01 11
+	ACCESS_KR,		// 10 00
+	ACCESS_KR, //	ACCESS_KRW,		// 10 01
+	ACCESS_UR,		// 10 10
+	ACCESS_UR,		// 10 11
+	ACCESS_KR,		// 11 00
+	ACCESS_KRW,		// 11 01
+	ACCESS_UR,		// 11 10
+	ACCESS_URW		// 11 11
+};
+
+// This array defines how a page is mapped depending on 
+// page access right, cpl==3, and WP.
+// R = map handler as read, W = map handler as write, E = map exception handler
+#define ACMAP_RW 0
+#define ACMAP_RE 1
+#define ACMAP_EE 2
+
+static const char* const lnm[] = {"RW ","RE ","EE "}; // debug stuff
+
+// bit0-1 ACCESS_ type
+// bit2   1=user mode
+// bit3   WP on
+
+static const Bit8u xlat_mapping[] = {
+//  KR        KRW       UR        URW
+	// index 0-3   kernel, wp 0
+	ACMAP_RW, ACMAP_RW, ACMAP_RW, ACMAP_RW,
+	// index 4-7   user,   wp 0
+	ACMAP_EE, ACMAP_EE, ACMAP_RE, ACMAP_RW,
+	// index 8-11  kernel, wp 1
+	ACMAP_RE, ACMAP_RW, ACMAP_RE, ACMAP_RW,
+	// index 11-15 user,   wp 1 (same as user, wp 0)
+	ACMAP_EE, ACMAP_EE, ACMAP_RE, ACMAP_RW,
+};
+
+// This table can figure out if we are going to fault right now in the init handler
+// (1=fault) 
+// bit0-1 ACCESS_ type
+// bit2   1=user mode
+// bit3   1=writing
+// bit4   wp
+
+static const Bit8u fault_table[] = {
+//	KR	KRW	UR	URW
+	// WP 0
+	// index 0-3   kernel, reading
+	0,	0,	0,	0,
+	// index 4-7   user,   reading
+	1,	1,	0,	0,
+	// index 8-11  kernel, writing
+	0,	0,	0,	0,
+	// index 11-15 user,   writing
+	1,	1,	1,	0,
+	// WP 1
+	// index 0-3   kernel, reading
+	0,	0,	0,	0,
+	// index 4-7   user,   reading
+	1,	1,	0,	0,
+	// index 8-11  kernel, writing
+	1,	0,	1,	0,
+	// index 11-15 user,   writing
+	1,	1,	1,	0,
+};
+
+#define PHYSPAGE_DITRY 0x10000000
+#define PHYSPAGE_ADDR  0x000FFFFF
+
+// helper functions for calculating table entry addresses
+static inline PhysPt GetPageDirectoryEntryAddr(PhysPt lin_addr) {
+	return paging.base.addr | ((lin_addr >> 22) << 2);
+}
+static inline PhysPt GetPageTableEntryAddr(PhysPt lin_addr, X86PageEntry& dir_entry) {
+	return (dir_entry.block.base<<12) | ((lin_addr >> 10) & 0xffc);
+}
+/*
+void PrintPageInfo(const char* string, PhysPt lin_addr, bool writing, bool prepare_only) {
+
+	Bitu lin_page=lin_addr >> 12;
+
+	X86PageEntry dir_entry, table_entry;
+	bool isUser = (((cpu.cpl & cpu.mpl)==3)? true:false);
+
+	PhysPt dirEntryAddr = GetPageDirectoryEntryAddr(lin_addr);
+	PhysPt tableEntryAddr = 0;
+	dir_entry.load=phys_readd(dirEntryAddr);
+	Bitu result = 4;
+	bool dirty = false;
+	Bitu ft_index = 0;
+
+	if (dir_entry.block.p) {
+		tableEntryAddr = GetPageTableEntryAddr(lin_addr, dir_entry);
+		table_entry.load=phys_readd(tableEntryAddr);
+		if (table_entry.block.p) {
+			result =
+				translate_array[((dir_entry.load<<1)&0xc) | ((table_entry.load>>1)&0x3)];
+
+			ft_index = result | (writing? 8:0) | (isUser? 4:0) |
+				(paging.wp? 16:0);
+
+			dirty = table_entry.block.d? true:false;
+		}
+	}
+	LOG_MSG("%s %s LIN% 8x PHYS% 5x wr%x ch%x wp%x d%x c%x m%x f%x a%x [%x/%x/%x]",
+		string, mtr[result], lin_addr, table_entry.block.base,
+		writing, prepare_only, paging.wp,
+		dirty, cpu.cpl, cpu.mpl, fault_table[ft_index],
+		((dir_entry.load<<1)&0xc) | ((table_entry.load>>1)&0x3),
+		dirEntryAddr, tableEntryAddr, table_entry.load);
+}
+*/
+
+// PAGING_NewPageFault
+// lin_addr, page_addr: the linear and page address the fault happened at
+// prepare_only: true in case the calling core handles the fault, else the PageFaultCore does
+static void PAGING_NewPageFault(PhysPt lin_addr, Bitu page_addr, 
+								bool prepare_only, Bitu faultcode) {
 	paging.cr2=lin_addr;
-	PF_Entry * entry=&pf_queue.entries[pf_queue.used++];
-	LOG(LOG_PAGING,LOG_NORMAL)("PageFault at %X type [%x] queue %d",lin_addr,faultcode,pf_queue.used);
-//	LOG_MSG("EAX:%04X ECX:%04X EDX:%04X EBX:%04X",reg_eax,reg_ecx,reg_edx,reg_ebx);
-//	LOG_MSG("CS:%04X EIP:%08X SS:%04x SP:%08X",SegValue(cs),reg_eip,SegValue(ss),reg_esp);
-	entry->cs=SegValue(cs);
-	entry->eip=reg_eip;
-	entry->page_addr=page_addr;
-	entry->mpl=cpu.mpl;
-	cpu.mpl=3;
+	//LOG_MSG("FAULT q%d, code %x",  pf_queue.used, faultcode);
+	//PrintPageInfo("FA+",lin_addr,faultcode, prepare_only);
 
-	CPU_Exception(EXCEPTION_PF,faultcode);
+	if (prepare_only) {
+		cpu.exception.which = EXCEPTION_PF;
+		cpu.exception.error = faultcode;
+	} else {
+		// Save the state of the cpu cores
+		LazyFlags old_lflags;
+		memcpy(&old_lflags,&lflags,sizeof(LazyFlags));
+		CPU_Decoder * old_cpudecoder;
+		old_cpudecoder=cpudecoder;
+		cpudecoder=&PageFaultCore;
+		if (pf_queue.used >= PF_QUEUESIZE) E_Exit("PF queue overrun.");
+		PF_Entry * entry=&pf_queue.entries[pf_queue.used++];
+		entry->cs=SegValue(cs);
+		entry->eip=reg_eip;
+		entry->page_addr=page_addr;
+		entry->mpl=cpu.mpl;
+		cpu.mpl=3;
+		CPU_Exception(EXCEPTION_PF,faultcode);
 #if C_DEBUG
-//	DEBUG_EnableDebugger();
+	//	DEBUG_EnableDebugger();
 #endif
-	DOSBOX_RunMachine();
-	pf_queue.used--;
-	LOG(LOG_PAGING,LOG_NORMAL)("Left PageFault for %x queue %d",lin_addr,pf_queue.used);
-	memcpy(&lflags,&old_lflags,sizeof(LazyFlags));
-	cpudecoder=old_cpudecoder;
-//	LOG_MSG("SS:%04x SP:%08X",SegValue(ss),reg_esp);
+		DOSBOX_RunMachine();
+		pf_queue.used--;
+		LOG(LOG_PAGING,LOG_NORMAL)("Left PageFault for %x queue %d",lin_addr,pf_queue.used);
+		memcpy(&lflags,&old_lflags,sizeof(LazyFlags));
+		cpudecoder=old_cpudecoder;
+		//LOG_MSG("FAULT exit");
+	}
 }
 
-static INLINE void InitPageUpdateLink(Bitu relink,PhysPt addr) {
-	if (relink==0) return;
-	if (paging.links.used) {
-		if (paging.links.entries[paging.links.used-1]==(addr>>12)) {
-			paging.links.used--;
-			PAGING_UnlinkPages(addr>>12,1);
-		}
+class PageFoilHandler : public PageHandler {
+private:
+	void work(PhysPt addr) {
+		Bitu lin_page = addr >> 12;
+		Bit32u phys_page = paging.tlb.phys_page[lin_page] & PHYSPAGE_ADDR;
+
+		// set the page dirty in the tlb
+		paging.tlb.phys_page[lin_page] |= PHYSPAGE_DITRY;
+
+		// mark the page table entry dirty
+		X86PageEntry dir_entry, table_entry;
+		
+		PhysPt dirEntryAddr = GetPageDirectoryEntryAddr(addr);
+		dir_entry.load=phys_readd(dirEntryAddr);
+		if (!dir_entry.block.p) E_Exit("Undesired situation 1 in page foiler.");
+
+		PhysPt tableEntryAddr = GetPageTableEntryAddr(addr, dir_entry);
+		table_entry.load=phys_readd(tableEntryAddr);
+		if (!table_entry.block.p) E_Exit("Undesired situation 2 in page foiler.");
+
+		// for debugging...
+		if (table_entry.block.base != phys_page)
+			E_Exit("Undesired situation 3 in page foiler.");
+
+		// map the real write handler in our place
+		PageHandler* handler = MEM_GetPageHandler(phys_page);
+
+		// debug
+//		LOG_MSG("FOIL            LIN% 8x PHYS% 8x [%x/%x/%x] WRP % 8x", addr, phys_page,
+//			dirEntryAddr, tableEntryAddr, table_entry.load, wtest);
+
+		// this can happen when the same page table is used at two different
+		// page directory entries / linear locations (WfW311)
+		// if (table_entry.block.d) E_Exit("% 8x Already dirty!!",table_entry.load);
+		
+		
+		// set the dirty bit
+		table_entry.block.d=1;
+		phys_writed(tableEntryAddr,table_entry.load);
+		
+		// replace this handler with the real thing
+		if (handler->flags & PFLAG_WRITEABLE)
+			paging.tlb.write[lin_page] = handler->GetHostWritePt(phys_page) - (lin_page << 12);
+		else paging.tlb.write[lin_page]=0;
+		paging.tlb.writehandler[lin_page]=handler;
+
+		return;
 	}
-	if (relink>1) PAGING_LinkPage_ReadOnly(addr>>12,relink);
-}
 
-static INLINE void InitPageCheckPresence(PhysPt lin_addr,bool writing,X86PageEntry& table,X86PageEntry& entry) {
-	Bitu lin_page=lin_addr >> 12;
-	Bitu d_index=lin_page >> 10;
-	Bitu t_index=lin_page & 0x3ff;
-	Bitu table_addr=(paging.base.page<<12)+d_index*4;
-	table.load=phys_readd(table_addr);
-	if (!table.block.p) {
-		LOG(LOG_PAGING,LOG_NORMAL)("NP Table");
-		PAGING_PageFault(lin_addr,table_addr,
-			(writing?0x02:0x00) | (((cpu.cpl&cpu.mpl)==0)?0x00:0x04));
-		table.load=phys_readd(table_addr);
-		if (GCC_UNLIKELY(!table.block.p))
-			E_Exit("Pagefault didn't correct table");
+	void read() {
+		E_Exit("The page foiler shouldn't be read.");
 	}
-	Bitu entry_addr=(table.block.base<<12)+t_index*4;
-	entry.load=phys_readd(entry_addr);
-	if (!entry.block.p) {
-//		LOG(LOG_PAGING,LOG_NORMAL)("NP Page");
-		PAGING_PageFault(lin_addr,entry_addr,
-			(writing?0x02:0x00) | (((cpu.cpl&cpu.mpl)==0)?0x00:0x04));
-		entry.load=phys_readd(entry_addr);
-		if (GCC_UNLIKELY(!entry.block.p))
-			E_Exit("Pagefault didn't correct page");
+public:
+	PageFoilHandler() {
+		flags=PFLAG_INIT|PFLAG_NOCODE; // ???
 	}
-}
-			
-static INLINE bool InitPageCheckPresence_CheckOnly(PhysPt lin_addr,bool writing,X86PageEntry& table,X86PageEntry& entry) {
-	Bitu lin_page=lin_addr >> 12;
-	Bitu d_index=lin_page >> 10;
-	Bitu t_index=lin_page & 0x3ff;
-	Bitu table_addr=(paging.base.page<<12)+d_index*4;
-	table.load=phys_readd(table_addr);
-	if (!table.block.p) {
-		paging.cr2=lin_addr;
-		cpu.exception.which=EXCEPTION_PF;
-		cpu.exception.error=(writing?0x02:0x00) | (((cpu.cpl&cpu.mpl)==0)?0x00:0x04);
+	Bitu readb(PhysPt addr) {read();return 0;}
+	Bitu readw(PhysPt addr) {read();return 0;}
+	Bitu readd(PhysPt addr) {read();return 0;}
+
+	void writeb(PhysPt addr,Bitu val) {
+		work(addr);
+		// execute the write:
+		// no need to care about mpl because we won't be entered
+		// if write isn't allowed
+		mem_writeb(addr, val);	
+	}
+	void writew(PhysPt addr,Bitu val) {
+		work(addr);
+		mem_writew(addr, val);
+	}
+	void writed(PhysPt addr,Bitu val) {
+		work(addr);
+		mem_writed(addr, val);
+	}
+
+	bool readb_checked(PhysPt addr, Bit8u * val) {read();return true;}
+	bool readw_checked(PhysPt addr, Bit16u * val) {read();return true;}
+	bool readd_checked(PhysPt addr, Bit32u * val) {read();return true;}
+
+	bool writeb_checked(PhysPt addr,Bitu val) {
+		work(addr);
+		mem_writeb(addr, val);
 		return false;
 	}
-	Bitu entry_addr=(table.block.base<<12)+t_index*4;
-	entry.load=phys_readd(entry_addr);
-	if (!entry.block.p) {
-		paging.cr2=lin_addr;
-		cpu.exception.which=EXCEPTION_PF;
-		cpu.exception.error=(writing?0x02:0x00) | (((cpu.cpl&cpu.mpl)==0)?0x00:0x04);
+	bool writew_checked(PhysPt addr,Bitu val) {
+		work(addr);
+		mem_writew(addr, val);
 		return false;
 	}
-	return true;
-}
+	bool writed_checked(PhysPt addr,Bitu val) {
+		work(addr);
+		mem_writed(addr, val);
+		return false;
+	}
+};
 
-// check if a user-level memory access would trigger a privilege page fault
-static INLINE bool InitPage_CheckUseraccess(Bitu u1,Bitu u2) {
-	switch (CPU_ArchitectureType) {
-	case CPU_ARCHTYPE_MIXED:
-	case CPU_ARCHTYPE_386SLOW:
-	case CPU_ARCHTYPE_386FAST:
-	default:
-		return ((u1)==0) && ((u2)==0);
-	case CPU_ARCHTYPE_486OLDSLOW:
-	case CPU_ARCHTYPE_486NEWSLOW:
-	case CPU_ARCHTYPE_PENTIUMSLOW:
-		return ((u1)==0) || ((u2)==0);
+class ExceptionPageHandler : public PageHandler {
+private:
+	PageHandler* getHandler(PhysPt addr) {
+		Bitu lin_page = addr >> 12;
+		Bit32u phys_page = paging.tlb.phys_page[lin_page] & PHYSPAGE_ADDR;
+		PageHandler* handler = MEM_GetPageHandler(phys_page);
+		return handler;
 	}
-}
 
+	bool hack_check(PhysPt addr) {
+		// First Encounters
+		// They change the page attributes without clearing the TLB.
+		// On a real 486 they get away with it because its TLB has only 32 or so 
+		// elements. The changed page attribs get overwritten and re-read before
+		// the exception happens. Here we have gazillions of TLB entries so the
+		// exception occurs if we don't check for it.
 
-class InitPageHandler : public PageHandler {
+		Bitu old_attirbs = paging.tlb.phys_page[addr>>12] >> 30;
+		X86PageEntry dir_entry, table_entry;
+		
+		dir_entry.load = phys_readd(GetPageDirectoryEntryAddr(addr));
+		if (!dir_entry.block.p) return false;
+		table_entry.load = phys_readd(GetPageTableEntryAddr(addr, dir_entry));
+		if (!table_entry.block.p) return false;
+		Bitu result =
+		translate_array[((dir_entry.load<<1)&0xc) | ((table_entry.load>>1)&0x3)];
+		if (result != old_attirbs) return true;
+		return false;
+	}
+
+	void Exception(PhysPt addr, bool writing, bool checked) {
+		//PrintPageInfo("XCEPT",addr,writing, checked);
+		//LOG_MSG("XCEPT LIN% 8x wr%d, ch%d, cpl%d, mpl%d",addr, writing, checked, cpu.cpl, cpu.mpl);
+		PhysPt tableaddr = 0;
+		if (!checked) {
+			X86PageEntry dir_entry;
+			dir_entry.load = phys_readd(GetPageDirectoryEntryAddr(addr));
+			if (!dir_entry.block.p) E_Exit("Undesired situation 1 in exception handler.");
+			
+			// page table entry
+			tableaddr = GetPageTableEntryAddr(addr, dir_entry);
+			//Bitu d_index=(addr >> 12) >> 10;
+			//tableaddr=(paging.base.page<<12) | (d_index<<2);
+		} 
+		PAGING_NewPageFault(addr, tableaddr, checked,
+			1 | (writing? 2:0) | (((cpu.cpl&cpu.mpl)==3)? 4:0));
+		
+		PAGING_ClearTLB(); // TODO got a better idea?
+	}
+
+	Bitu readb_through(PhysPt addr) {
+		Bitu lin_page = addr >> 12;
+		Bit32u phys_page = paging.tlb.phys_page[lin_page] & PHYSPAGE_ADDR;
+		PageHandler* handler = MEM_GetPageHandler(phys_page);
+		if (handler->flags & PFLAG_READABLE) {
+			return host_readb(handler->GetHostReadPt(phys_page) + (addr&0xfff));
+		}
+		else return handler->readb(addr);
+	}
+	Bitu readw_through(PhysPt addr) {
+		Bitu lin_page = addr >> 12;
+		Bit32u phys_page = paging.tlb.phys_page[lin_page] & PHYSPAGE_ADDR;
+		PageHandler* handler = MEM_GetPageHandler(phys_page);
+		if (handler->flags & PFLAG_READABLE) {
+			return host_readw(handler->GetHostReadPt(phys_page) + (addr&0xfff));
+		}
+		else return handler->readw(addr);
+	}
+	Bitu readd_through(PhysPt addr) {
+		Bitu lin_page = addr >> 12;
+		Bit32u phys_page = paging.tlb.phys_page[lin_page] & PHYSPAGE_ADDR;
+		PageHandler* handler = MEM_GetPageHandler(phys_page);
+		if (handler->flags & PFLAG_READABLE) {
+			return host_readd(handler->GetHostReadPt(phys_page) + (addr&0xfff));
+		}
+		else return handler->readd(addr);
+	}
+
+	void writeb_through(PhysPt addr, Bitu val) {
+		Bitu lin_page = addr >> 12;
+		Bit32u phys_page = paging.tlb.phys_page[lin_page] & PHYSPAGE_ADDR;
+		PageHandler* handler = MEM_GetPageHandler(phys_page);
+		if (handler->flags & PFLAG_WRITEABLE) {
+			return host_writeb(handler->GetHostWritePt(phys_page) + (addr&0xfff), (Bit8u)val);
+		}
+		else return handler->writeb(addr, val);
+	}
+
+	void writew_through(PhysPt addr, Bitu val) {
+		Bitu lin_page = addr >> 12;
+		Bit32u phys_page = paging.tlb.phys_page[lin_page] & PHYSPAGE_ADDR;
+		PageHandler* handler = MEM_GetPageHandler(phys_page);
+		if (handler->flags & PFLAG_WRITEABLE) {
+			return host_writew(handler->GetHostWritePt(phys_page) + (addr&0xfff), (Bit16u)val);
+		}
+		else return handler->writew(addr, val);
+	}
+
+	void writed_through(PhysPt addr, Bitu val) {
+		Bitu lin_page = addr >> 12;
+		Bit32u phys_page = paging.tlb.phys_page[lin_page] & PHYSPAGE_ADDR;
+		PageHandler* handler = MEM_GetPageHandler(phys_page);
+		if (handler->flags & PFLAG_WRITEABLE) {
+			return host_writed(handler->GetHostWritePt(phys_page) + (addr&0xfff), val);
+		}
+		else return handler->writed(addr, val);
+	}
+
 public:
-	InitPageHandler() {
-		flags=PFLAG_INIT|PFLAG_NOCODE;
+	ExceptionPageHandler() {
+		flags=PFLAG_INIT|PFLAG_NOCODE; // ???
 	}
 	Bitu readb(PhysPt addr) {
-		Bitu needs_reset=InitPage(addr,false);
-		Bit8u val=mem_readb(addr);
-		InitPageUpdateLink(needs_reset,addr);
-		return val;
+		if (!cpu.mpl) return readb_through(addr);
+
+		Exception(addr, false, false);
+		return mem_readb(addr); // read the updated page (unlikely to happen?)
 	}
 	Bitu readw(PhysPt addr) {
-		Bitu needs_reset=InitPage(addr,false);
-		Bit16u val=mem_readw(addr);
-		InitPageUpdateLink(needs_reset,addr);
-		return val;
+		// access type is supervisor mode (temporary)
+		// we are always allowed to read in superuser mode
+		// so get the handler and address and read it
+		if (!cpu.mpl) return readw_through(addr);
+
+		Exception(addr, false, false);
+		return mem_readw(addr);
 	}
 	Bitu readd(PhysPt addr) {
-		Bitu needs_reset=InitPage(addr,false);
-		Bit32u val=mem_readd(addr);
-		InitPageUpdateLink(needs_reset,addr);
-		return val;
+		if (!cpu.mpl) return readd_through(addr);
+
+		Exception(addr, false, false);
+		return mem_readd(addr);
 	}
 	void writeb(PhysPt addr,Bitu val) {
-		Bitu needs_reset=InitPage(addr,true);
-		mem_writeb(addr,val);
-		InitPageUpdateLink(needs_reset,addr);
+		if (!cpu.mpl) {
+			writeb_through(addr, val);
+			return;
+		}
+		Exception(addr, true, false);
+		mem_writeb(addr, val);
 	}
 	void writew(PhysPt addr,Bitu val) {
-		Bitu needs_reset=InitPage(addr,true);
-		mem_writew(addr,val);
-		InitPageUpdateLink(needs_reset,addr);
+		if (!cpu.mpl) {
+			// TODO Exception on a KR-page?
+			writew_through(addr, val);
+			return;
+		}
+		if (hack_check(addr)) {
+			LOG_MSG("Page attributes modified without clear");
+			PAGING_ClearTLB();
+			mem_writew(addr,val);
+			return;
+		}
+		// firstenc here
+		Exception(addr, true, false);
+		mem_writew(addr, val);
 	}
 	void writed(PhysPt addr,Bitu val) {
-		Bitu needs_reset=InitPage(addr,true);
-		mem_writed(addr,val);
-		InitPageUpdateLink(needs_reset,addr);
+		if (!cpu.mpl) {
+			writed_through(addr, val);
+			return;
+		}
+		Exception(addr, true, false);
+		mem_writed(addr, val);
 	}
+	// returning true means an exception was triggered for these _checked functions
 	bool readb_checked(PhysPt addr, Bit8u * val) {
-		if (InitPageCheckOnly(addr,false)) {
-			*val=mem_readb(addr);
-			return false;
-		} else return true;
+		Exception(addr, false, true);
+		return true;
 	}
 	bool readw_checked(PhysPt addr, Bit16u * val) {
-		if (InitPageCheckOnly(addr,false)){
-			*val=mem_readw(addr);
-			return false;
-		} else return true;
+		Exception(addr, false, true);
+		return true;
 	}
 	bool readd_checked(PhysPt addr, Bit32u * val) {
-		if (InitPageCheckOnly(addr,false)) {
-			*val=mem_readd(addr);
-			return false;
-		} else return true;
+		Exception(addr, false, true);
+		return true;
 	}
 	bool writeb_checked(PhysPt addr,Bitu val) {
-		if (InitPageCheckOnly(addr,true)) {
-			mem_writeb(addr,val);
-			return false;
-		} else return true;
+		Exception(addr, true, true);
+		return true;
 	}
 	bool writew_checked(PhysPt addr,Bitu val) {
-		if (InitPageCheckOnly(addr,true)) {
-			mem_writew(addr,val);
+		if (hack_check(addr)) {
+			LOG_MSG("Page attributes modified without clear");
+			PAGING_ClearTLB();
+			mem_writew(addr,val); // TODO this makes us recursive again?
 			return false;
-		} else return true;
+		}
+		Exception(addr, true, true);
+		return true;
 	}
 	bool writed_checked(PhysPt addr,Bitu val) {
-		if (InitPageCheckOnly(addr,true)) {
-			mem_writed(addr,val);
-			return false;
-		} else return true;
-	}
-	Bitu InitPage(Bitu lin_addr,bool writing) {
-		Bitu lin_page=lin_addr >> 12;
-		Bitu phys_page;
-		if (paging.enabled) {
-			X86PageEntry table;
-			X86PageEntry entry;
-			InitPageCheckPresence(lin_addr,writing,table,entry);
-
-			// 0: no action
-			// 1: can (but currently does not) fail a user-level access privilege check
-			// 2: can (but currently does not) fail a write privilege check
-			// 3: fails a privilege check
-			Bitu priv_check=0;
-			if (InitPage_CheckUseraccess(entry.block.us,table.block.us)) {
-				if ((cpu.cpl&cpu.mpl)==3) priv_check=3;
-				else {
-					switch (CPU_ArchitectureType) {
-					case CPU_ARCHTYPE_MIXED:
-					case CPU_ARCHTYPE_386FAST:
-					default:
-//						priv_check=0;	// default
-						break;
-					case CPU_ARCHTYPE_386SLOW:
-					case CPU_ARCHTYPE_486OLDSLOW:
-					case CPU_ARCHTYPE_486NEWSLOW:
-					case CPU_ARCHTYPE_PENTIUMSLOW:
-						priv_check=1;
-						break;
-					}
-				}
-			}
-			if ((entry.block.wr==0) || (table.block.wr==0)) {
-				// page is write-protected for user mode
-				if (priv_check==0) {
-					switch (CPU_ArchitectureType) {
-					case CPU_ARCHTYPE_MIXED:
-					case CPU_ARCHTYPE_386FAST:
-					default:
-//						priv_check=0;	// default
-						break;
-					case CPU_ARCHTYPE_386SLOW:
-					case CPU_ARCHTYPE_486OLDSLOW:
-					case CPU_ARCHTYPE_486NEWSLOW:
-					case CPU_ARCHTYPE_PENTIUMSLOW:
-						priv_check=2;
-						break;
-					}
-				}
-				// check if actually failing the write-protected check
-				if (writing && USERWRITE_PROHIBITED) priv_check=3;
-			}
-			if (priv_check==3) {
-				LOG(LOG_PAGING,LOG_NORMAL)("Page access denied: cpl=%i, %x:%x:%x:%x",
-					cpu.cpl,entry.block.us,table.block.us,entry.block.wr,table.block.wr);
-				PAGING_PageFault(lin_addr,(table.block.base<<12)+(lin_page & 0x3ff)*4,0x05 | (writing?0x02:0x00));
-				priv_check=0;
-			}
-
-			if (!table.block.a) {
-				table.block.a=1;		// set page table accessed
-				phys_writed((paging.base.page<<12)+(lin_page >> 10)*4,table.load);
-			}
-			if ((!entry.block.a) || (!entry.block.d)) {
-				entry.block.a=1;		// set page accessed
-
-				// page is dirty if we're writing to it, or if we're reading but the
-				// page will be fully linked so we can't track later writes
-				if (writing || (priv_check==0)) entry.block.d=1;		// mark page as dirty
-
-				phys_writed((table.block.base<<12)+(lin_page & 0x3ff)*4,entry.load);
-			}
-
-			phys_page=entry.block.base;
-			
-			// now see how the page should be linked best, if we need to catch privilege
-			// checks later on it should be linked as read-only page
-			if (priv_check==0) {
-				// if reading we could link the page as read-only to later cacth writes,
-				// will slow down pretty much but allows catching all dirty events
-				PAGING_LinkPage(lin_page,phys_page);
-			} else {
-				if (priv_check==1) {
-					PAGING_LinkPage(lin_page,phys_page);
-					return 1;
-				} else if (writing) {
-					PageHandler * handler=MEM_GetPageHandler(phys_page);
-					PAGING_LinkPage(lin_page,phys_page);
-					if (!(handler->flags & PFLAG_READABLE)) return 1;
-					if (!(handler->flags & PFLAG_WRITEABLE)) return 1;
-					if (get_tlb_read(lin_addr)!=get_tlb_write(lin_addr)) return 1;
-					if (phys_page>1) return phys_page;
-					else return 1;
-				} else {
-					PAGING_LinkPage_ReadOnly(lin_page,phys_page);
-				}
-			}
-		} else {
-			if (lin_page<LINK_START) phys_page=paging.firstmb[lin_page];
-			else phys_page=lin_page;
-			PAGING_LinkPage(lin_page,phys_page);
-		}
-		return 0;
-	}
-	bool InitPageCheckOnly(Bitu lin_addr,bool writing) {
-		Bitu lin_page=lin_addr >> 12;
-		if (paging.enabled) {
-			X86PageEntry table;
-			X86PageEntry entry;
-			if (!InitPageCheckPresence_CheckOnly(lin_addr,writing,table,entry)) return false;
-
-			if (!USERWRITE_PROHIBITED) return true;
-
-			if (InitPage_CheckUseraccess(entry.block.us,table.block.us) ||
-					(((entry.block.wr==0) || (table.block.wr==0)) && writing)) {
-				LOG(LOG_PAGING,LOG_NORMAL)("Page access denied: cpl=%i, %x:%x:%x:%x",
-					cpu.cpl,entry.block.us,table.block.us,entry.block.wr,table.block.wr);
-				paging.cr2=lin_addr;
-				cpu.exception.which=EXCEPTION_PF;
-				cpu.exception.error=0x05 | (writing?0x02:0x00);
-				return false;
-			}
-		} else {
-			Bitu phys_page;
-			if (lin_page<LINK_START) phys_page=paging.firstmb[lin_page];
-			else phys_page=lin_page;
-			PAGING_LinkPage(lin_page,phys_page);
-		}
+		Exception(addr, true, true);
 		return true;
 	}
-	void InitPageForced(Bitu lin_addr) {
-		Bitu lin_page=lin_addr >> 12;
-		Bitu phys_page;
-		if (paging.enabled) {
-			X86PageEntry table;
-			X86PageEntry entry;
-			InitPageCheckPresence(lin_addr,false,table,entry);
-
-			if (!table.block.a) {
-				table.block.a=1;		//Set access
-				phys_writed((paging.base.page<<12)+(lin_page >> 10)*4,table.load);
-			}
-			if (!entry.block.a) {
-				entry.block.a=1;					//Set access
-				phys_writed((table.block.base<<12)+(lin_page & 0x3ff)*4,entry.load);
-			}
-			phys_page=entry.block.base;
-			// maybe use read-only page here if possible
-		} else {
-			if (lin_page<LINK_START) phys_page=paging.firstmb[lin_page];
-			else phys_page=lin_page;
-		}
-		PAGING_LinkPage(lin_page,phys_page);
-	}
 };
 
-class InitPageUserROHandler : public PageHandler {
+static void PAGING_LinkPageNew(Bitu lin_page, Bitu phys_page, Bitu linkmode, bool dirty);
+
+class NewInitPageHandler : public PageHandler {
 public:
-	InitPageUserROHandler() {
+	NewInitPageHandler() {
 		flags=PFLAG_INIT|PFLAG_NOCODE;
 	}
+	Bitu readb(PhysPt addr) {
+		InitPage(addr, false, false);
+		return mem_readb(addr);
+	}
+	Bitu readw(PhysPt addr) {
+		InitPage(addr, false, false);
+		return mem_readw(addr);
+	}
+	Bitu readd(PhysPt addr) {
+		InitPage(addr, false, false);
+		return mem_readd(addr);
+	}
 	void writeb(PhysPt addr,Bitu val) {
-		InitPage(addr,(Bit8u)(val&0xff));
-		host_writeb(get_tlb_read(addr)+addr,(Bit8u)(val&0xff));
+		InitPage(addr, true, false);
+		mem_writeb(addr,val);
 	}
 	void writew(PhysPt addr,Bitu val) {
-		InitPage(addr,(Bit16u)(val&0xffff));
-		host_writew(get_tlb_read(addr)+addr,(Bit16u)(val&0xffff));
+		InitPage(addr, true, false);
+		mem_writew(addr,val);
 	}
 	void writed(PhysPt addr,Bitu val) {
-		InitPage(addr,(Bit32u)val);
-		host_writed(get_tlb_read(addr)+addr,(Bit32u)val);
+		InitPage(addr, true, false);
+		mem_writed(addr,val);
 	}
+
+	bool readb_checked(PhysPt addr, Bit8u * val) {
+		if (InitPage(addr, false, true)) return true;
+		*val=mem_readb(addr);
+		return false;
+	}
+	bool readw_checked(PhysPt addr, Bit16u * val) {
+		if (InitPage(addr, false, true)) return true;
+		*val=mem_readw(addr);
+		return false;
+	}
+	bool readd_checked(PhysPt addr, Bit32u * val) {
+		if (InitPage(addr, false, true)) return true;
+		*val=mem_readd(addr);
+		return false;
+	}
 	bool writeb_checked(PhysPt addr,Bitu val) {
-		Bitu writecode=InitPageCheckOnly(addr,(Bit8u)(val&0xff));
-		if (writecode) {
-			HostPt tlb_addr;
-			if (writecode>1) tlb_addr=get_tlb_read(addr);
-			else tlb_addr=get_tlb_write(addr);
-			host_writeb(tlb_addr+addr,(Bit8u)(val&0xff));
-			return false;
-		}
-		return true;
+		if (InitPage(addr, true, true)) return true;
+		mem_writeb(addr,val);
+		return false;
 	}
 	bool writew_checked(PhysPt addr,Bitu val) {
-		Bitu writecode=InitPageCheckOnly(addr,(Bit16u)(val&0xffff));
-		if (writecode) {
-			HostPt tlb_addr;
-			if (writecode>1) tlb_addr=get_tlb_read(addr);
-			else tlb_addr=get_tlb_write(addr);
-			host_writew(tlb_addr+addr,(Bit16u)(val&0xffff));
-			return false;
-		}
-		return true;
+		if (InitPage(addr, true, true)) return true;
+		mem_writew(addr,val);
+		return false;
 	}
 	bool writed_checked(PhysPt addr,Bitu val) {
-		Bitu writecode=InitPageCheckOnly(addr,(Bit32u)val);
-		if (writecode) {
-			HostPt tlb_addr;
-			if (writecode>1) tlb_addr=get_tlb_read(addr);
-			else tlb_addr=get_tlb_write(addr);
-			host_writed(tlb_addr+addr,(Bit32u)val);
-			return false;
-		}
-		return true;
+		if (InitPage(addr, true, true)) return true;
+		mem_writed(addr,val);
+		return false;
 	}
-	void InitPage(Bitu lin_addr,Bitu val) {
+	bool InitPage(PhysPt lin_addr, bool writing, bool prepare_only) {
 		Bitu lin_page=lin_addr >> 12;
 		Bitu phys_page;
 		if (paging.enabled) {
-			if (!USERWRITE_PROHIBITED) return;
+initpage_retry:
+			X86PageEntry dir_entry, table_entry;
+			bool isUser = (((cpu.cpl & cpu.mpl)==3)? true:false);
 
-			X86PageEntry table;
-			X86PageEntry entry;
-			InitPageCheckPresence(lin_addr,true,table,entry);
+			// Read the paging stuff, throw not present exceptions if needed
+			// and find out how the page should be mapped
+			PhysPt dirEntryAddr = GetPageDirectoryEntryAddr(lin_addr);
+			dir_entry.load=phys_readd(dirEntryAddr);
 
-			LOG(LOG_PAGING,LOG_NORMAL)("Page access denied: cpl=%i, %x:%x:%x:%x",
-				cpu.cpl,entry.block.us,table.block.us,entry.block.wr,table.block.wr);
-			PAGING_PageFault(lin_addr,(table.block.base<<12)+(lin_page & 0x3ff)*4,0x07);
+			if (!dir_entry.block.p) {
+				// table pointer is not present, do a page fault
+				PAGING_NewPageFault(lin_addr, dirEntryAddr, prepare_only,
+					(writing? 2:0) | (isUser? 4:0));
+				
+				if (prepare_only) return true;
+				else goto initpage_retry; // TODO maybe E_Exit after a few loops
+			}
+			PhysPt tableEntryAddr = GetPageTableEntryAddr(lin_addr, dir_entry);
+			table_entry.load=phys_readd(tableEntryAddr);
 
-			if (!table.block.a) {
-				table.block.a=1;		//Set access
-				phys_writed((paging.base.page<<12)+(lin_page >> 10)*4,table.load);
+			// set page table accessed (IA manual: A is set whenever the entry is 
+			// used in a page translation)
+			if (!dir_entry.block.a) {
+				dir_entry.block.a = 1;		
+				phys_writed(dirEntryAddr, dir_entry.load);
 			}
-			if ((!entry.block.a) || (!entry.block.d)) {
-				entry.block.a=1;	//Set access
-				entry.block.d=1;	//Set dirty
-				phys_writed((table.block.base<<12)+(lin_page & 0x3ff)*4,entry.load);
+
+			if (!table_entry.block.p) {
+				// physpage pointer is not present, do a page fault
+				PAGING_NewPageFault(lin_addr, tableEntryAddr, prepare_only,
+					 (writing? 2:0) | (isUser? 4:0));
+				
+				if (prepare_only) return true;
+				else goto initpage_retry;
 			}
-			phys_page=entry.block.base;
-			PAGING_LinkPage(lin_page,phys_page);
-		} else {
-			if (lin_page<LINK_START) phys_page=paging.firstmb[lin_page];
-			else phys_page=lin_page;
-			PAGING_LinkPage(lin_page,phys_page);
-		}
-	}
-	Bitu InitPageCheckOnly(Bitu lin_addr,Bitu val) {
-		Bitu lin_page=lin_addr >> 12;
-		if (paging.enabled) {
-			if (!USERWRITE_PROHIBITED) return 2;
+			//PrintPageInfo("INI",lin_addr,writing,prepare_only);
 
-			X86PageEntry table;
-			X86PageEntry entry;
-			if (!InitPageCheckPresence_CheckOnly(lin_addr,true,table,entry)) return 0;
+			Bitu result =
+				translate_array[((dir_entry.load<<1)&0xc) | ((table_entry.load>>1)&0x3)];
+			
+			// If a page access right exception occurs we shouldn't change a or d
+			// I'd prefer running into the prepared exception handler but we'd need
+			// an additional handler that sets the 'a' bit - idea - foiler read?
+			Bitu ft_index = result | (writing? 8:0) | (isUser? 4:0) |
+				(paging.wp? 16:0);
+			
+			if (GCC_UNLIKELY(fault_table[ft_index])) {
+				// exception error code format: 
+				// bit0 - protection violation, bit1 - writing, bit2 - user mode
+				PAGING_NewPageFault(lin_addr, tableEntryAddr, prepare_only,
+					1 | (writing? 2:0) | (isUser? 4:0));
+				
+				if (prepare_only) return true;
+				else goto initpage_retry; // unlikely to happen?
+			}
+			// save load to see if it changed later
+			Bit32u table_load = table_entry.load;
 
-			if (InitPage_CheckUseraccess(entry.block.us,table.block.us) || (((entry.block.wr==0) || (table.block.wr==0)))) {
-				LOG(LOG_PAGING,LOG_NORMAL)("Page access denied: cpl=%i, %x:%x:%x:%x",
-					cpu.cpl,entry.block.us,table.block.us,entry.block.wr,table.block.wr);
-				paging.cr2=lin_addr;
-				cpu.exception.which=EXCEPTION_PF;
-				cpu.exception.error=0x07;
-				return 0;
-			}
-			PAGING_LinkPage(lin_page,entry.block.base);
-		} else {
-			Bitu phys_page;
+			// if we are writing we can set it right here to save some CPU
+			if (writing) table_entry.block.d = 1;
+
+			// set page accessed
+			table_entry.block.a = 1;
+			
+			// update if needed
+			if (table_load != table_entry.load)
+				phys_writed(tableEntryAddr, table_entry.load);
+
+			// if the page isn't dirty and we are reading we need to map the foiler
+			// (dirty = false)
+			bool dirty = table_entry.block.d? true:false;
+/*
+			LOG_MSG("INIT  %s LIN% 8x PHYS% 5x wr%x ch%x wp%x d%x c%x m%x a%x [%x/%x/%x]",
+				mtr[result], lin_addr, table_entry.block.base,
+				writing, prepare_only, paging.wp,
+				dirty, cpu.cpl, cpu.mpl,
+				((dir_entry.load<<1)&0xc) | ((table_entry.load>>1)&0x3),
+				dirEntryAddr, tableEntryAddr, table_entry.load);
+*/
+			// finally install the new page
+			PAGING_LinkPageNew(lin_page, table_entry.block.base, result, dirty);
+
+		} else { // paging off
 			if (lin_page<LINK_START) phys_page=paging.firstmb[lin_page];
 			else phys_page=lin_page;
 			PAGING_LinkPage(lin_page,phys_page);
 		}
-		return 1;
+		return false;
 	}
-	void InitPageForced(Bitu lin_addr) {
-		Bitu lin_page=lin_addr >> 12;
-		Bitu phys_page;
-		if (paging.enabled) {
-			X86PageEntry table;
-			X86PageEntry entry;
-			InitPageCheckPresence(lin_addr,true,table,entry);
-
-			if (!table.block.a) {
-				table.block.a=1;		//Set access
-				phys_writed((paging.base.page<<12)+(lin_page >> 10)*4,table.load);
-			}
-			if (!entry.block.a) {
-				entry.block.a=1;	//Set access
-				phys_writed((table.block.base<<12)+(lin_page & 0x3ff)*4,entry.load);
-			}
-			phys_page=entry.block.base;
-		} else {
-			if (lin_page<LINK_START) phys_page=paging.firstmb[lin_page];
-			else phys_page=lin_page;
-		}
-		PAGING_LinkPage(lin_page,phys_page);
-	}
 };
 
-
 bool PAGING_MakePhysPage(Bitu & page) {
+	// page is the linear address on entry
 	if (paging.enabled) {
-		Bitu d_index=page >> 10;
-		Bitu t_index=page & 0x3ff;
-		X86PageEntry table;
-		table.load=phys_readd((paging.base.page<<12)+d_index*4);
-		if (!table.block.p) return false;
-		X86PageEntry entry;
-		entry.load=phys_readd((table.block.base<<12)+t_index*4);
-		if (!entry.block.p) return false;
-		page=entry.block.base;
+		// check the page directory entry for this address
+		X86PageEntry dir_entry;
+		dir_entry.load = phys_readd(GetPageDirectoryEntryAddr(page<<12));
+		if (!dir_entry.block.p) return false;
+		
+		// check the page table entry
+		X86PageEntry tbl_entry;
+		tbl_entry.load = phys_readd(GetPageTableEntryAddr(page<<12, dir_entry));
+		if (!tbl_entry.block.p) return false;
+
+		// return it
+		page = tbl_entry.block.base;
 	} else {
 		if (page<LINK_START) page=paging.firstmb[page];
 		//Else keep it the same
@@ -622,27 +779,14 @@
 	return true;
 }
 
-static InitPageHandler init_page_handler;
-static InitPageUserROHandler init_page_handler_userro;
+static NewInitPageHandler init_page_handler;
+static ExceptionPageHandler exception_handler;
+static PageFoilHandler foiling_handler;
 
-
 Bitu PAGING_GetDirBase(void) {
 	return paging.cr3;
 }
 
-bool PAGING_ForcePageInit(Bitu lin_addr) {
-	PageHandler * handler=get_tlb_readhandler(lin_addr);
-	if (handler==&init_page_handler) {
-		init_page_handler.InitPageForced(lin_addr);
-		return true;
-	} else if (handler==&init_page_handler_userro) {
-		PAGING_UnlinkPages(lin_addr>>12,1);
-		init_page_handler_userro.InitPageForced(lin_addr);
-		return true;
-	}
-	return false;
-}
-
 #if defined(USE_FULL_TLB)
 void PAGING_InitTLB(void) {
 	for (Bitu i=0;i<TLB_SIZE;i++) {
@@ -651,10 +795,16 @@
 		paging.tlb.readhandler[i]=&init_page_handler;
 		paging.tlb.writehandler[i]=&init_page_handler;
 	}
+	paging.ur_links.used=0;
+	paging.krw_links.used=0;
+	paging.kr_links.used=0;
 	paging.links.used=0;
 }
 
 void PAGING_ClearTLB(void) {
+//	LOG_MSG("CLEAR                          m% 4u, kr% 4u, krw% 4u, ur% 4u",
+//		paging.links.used, paging.kro_links.used, paging.krw_links.used, paging.ure_links.used);
+
 	Bit32u * entries=&paging.links.entries[0];
 	for (;paging.links.used>0;paging.links.used--) {
 		Bitu page=*entries++;
@@ -663,6 +813,9 @@
 		paging.tlb.readhandler[page]=&init_page_handler;
 		paging.tlb.writehandler[page]=&init_page_handler;
 	}
+	paging.ur_links.used=0;
+	paging.krw_links.used=0;
+	paging.kr_links.used=0;
 	paging.links.used=0;
 }
 
@@ -688,6 +841,82 @@
 	}
 }
 
+static void PAGING_LinkPageNew(Bitu lin_page, Bitu phys_page, Bitu linkmode, bool dirty) {
+	Bitu xlat_index = linkmode | (paging.wp? 8:0) | ((cpu.cpl==3)? 4:0);
+	Bit8u outcome = xlat_mapping[xlat_index];
+
+	// get the physpage handler we are going to map 
+	PageHandler * handler=MEM_GetPageHandler(phys_page);
+	Bitu lin_base=lin_page << 12;
+	
+//	LOG_MSG("MAPPG %s",lnm[outcome]);
+	
+	if (GCC_UNLIKELY(lin_page>=TLB_SIZE || phys_page>=TLB_SIZE)) 
+		E_Exit("Illegal page");
+	if (GCC_UNLIKELY(paging.links.used>=PAGING_LINKS)) {
+		LOG(LOG_PAGING,LOG_NORMAL)("Not enough paging links, resetting cache");
+		PAGING_ClearTLB();
+	}
+	// re-use some of the unused bits in the phys_page variable
+	// needed in the exception handler and foiler so they can replace themselves appropriately
+	// bit31-30 ACMAP_
+	// bit29	dirty
+	// these bits are shifted off at the places paging.tlb.phys_page is read
+	paging.tlb.phys_page[lin_page]= phys_page | (linkmode<< 30) | (dirty? PHYSPAGE_DITRY:0);
+	switch(outcome) {
+	case ACMAP_RW:
+		// read
+		if (handler->flags & PFLAG_READABLE) paging.tlb.read[lin_page] = 
+			handler->GetHostReadPt(phys_page)-lin_base;
+		else paging.tlb.read[lin_page]=0;
+		paging.tlb.readhandler[lin_page]=handler;
+		
+		// write
+		if (dirty) { // in case it is already dirty we don't need to check
+			if (handler->flags & PFLAG_WRITEABLE) paging.tlb.write[lin_page] = 
+				handler->GetHostWritePt(phys_page)-lin_base;
+			else paging.tlb.write[lin_page]=0;
+			paging.tlb.writehandler[lin_page]=handler;
+		} else {
+			paging.tlb.writehandler[lin_page]= &foiling_handler;
+			paging.tlb.write[lin_page]=0;
+		}
+		break;
+	case ACMAP_RE:
+		// read
+		if (handler->flags & PFLAG_READABLE) paging.tlb.read[lin_page] = 
+			handler->GetHostReadPt(phys_page)-lin_base;
+		else paging.tlb.read[lin_page]=0;
+		paging.tlb.readhandler[lin_page]=handler;
+		// exception
+		paging.tlb.writehandler[lin_page]= &exception_handler;
+		paging.tlb.write[lin_page]=0;
+		break;
+	case ACMAP_EE:
+		paging.tlb.readhandler[lin_page]= &exception_handler;
+		paging.tlb.writehandler[lin_page]= &exception_handler;
+		paging.tlb.read[lin_page]=0;
+		paging.tlb.write[lin_page]=0;
+		break;
+	}
+
+	switch(linkmode) {
+	case ACCESS_KR:
+		paging.kr_links.entries[paging.kr_links.used++]=lin_page;
+		break;
+	case ACCESS_KRW:
+		paging.krw_links.entries[paging.krw_links.used++]=lin_page;
+		break;
+	case ACCESS_UR:
+		paging.ur_links.entries[paging.ur_links.used++]=lin_page;
+		break;
+	case ACCESS_URW:	// with this access right everything is possible
+						// thus no need to modify it on a us <-> sv switch
+		break;
+	}
+	paging.links.entries[paging.links.used++]=lin_page; // "master table"
+}
+
 void PAGING_LinkPage(Bitu lin_page,Bitu phys_page) {
 	PageHandler * handler=MEM_GetPageHandler(phys_page);
 	Bitu lin_base=lin_page << 12;
@@ -710,25 +939,108 @@
 	paging.tlb.writehandler[lin_page]=handler;
 }
 
-void PAGING_LinkPage_ReadOnly(Bitu lin_page,Bitu phys_page) {
-	PageHandler * handler=MEM_GetPageHandler(phys_page);
-	Bitu lin_base=lin_page << 12;
-	if (lin_page>=TLB_SIZE || phys_page>=TLB_SIZE) 
-		E_Exit("Illegal page");
+// parameter is the new cpl mode
+void PAGING_SwitchCPL(bool isUser) {
+//	LOG_MSG("SWCPL u%d kr%d, krw%d, ur%d",
+//		isUser, paging.kro_links.used, paging.krw_links.used, paging.ure_links.used);
+	
+	// this function is worth optimizing
+	// some of this cold be pre-stored?
 
-	if (paging.links.used>=PAGING_LINKS) {
-		LOG(LOG_PAGING,LOG_NORMAL)("Not enough paging links, resetting cache");
-		PAGING_ClearTLB();
+	// krw - same for WP1 and WP0
+	if (isUser) {
+		// sv -> us: rw -> ee 
+		for(Bitu i = 0; i < paging.krw_links.used; i++) {
+			Bitu tlb_index = paging.krw_links.entries[i];
+			paging.tlb.readhandler[tlb_index] = &exception_handler;
+			paging.tlb.writehandler[tlb_index] = &exception_handler;
+			paging.tlb.read[tlb_index] = 0;
+			paging.tlb.write[tlb_index] = 0;
+		}
+	} else {
+		// us -> sv: ee -> rw
+		for(Bitu i = 0; i < paging.krw_links.used; i++) {
+			Bitu tlb_index = paging.krw_links.entries[i];
+			Bitu phys_page = paging.tlb.phys_page[tlb_index];
+			Bitu lin_base = tlb_index << 12;
+			bool dirty = (phys_page & PHYSPAGE_DITRY)? true:false;
+			phys_page &= PHYSPAGE_ADDR;
+			PageHandler* handler = MEM_GetPageHandler(phys_page);
+			
+			// map read handler
+			paging.tlb.readhandler[tlb_index] = handler;
+			if (handler->flags&PFLAG_READABLE)
+				paging.tlb.read[tlb_index] = handler->GetHostReadPt(phys_page)-lin_base;
+			else paging.tlb.read[tlb_index] = 0;
+			
+			// map write handler
+			if (dirty) {
+				paging.tlb.writehandler[tlb_index] = handler;
+				if (handler->flags&PFLAG_WRITEABLE)
+					paging.tlb.write[tlb_index] = handler->GetHostWritePt(phys_page)-lin_base;
+				else paging.tlb.write[tlb_index] = 0;
+			} else {
+				paging.tlb.writehandler[tlb_index] = &foiling_handler;
+				paging.tlb.write[tlb_index] = 0;
+			}
+		}
 	}
+	
+	if (GCC_UNLIKELY(paging.wp)) {
+		// ur: no change with WP=1
+		// kr
+		if (isUser) {
+			// sv -> us: re -> ee 
+			for(Bitu i = 0; i < paging.kr_links.used; i++) {
+				Bitu tlb_index = paging.kr_links.entries[i];
+				paging.tlb.readhandler[tlb_index] = &exception_handler;
+				paging.tlb.read[tlb_index] = 0;
+			}
+		} else {
+			// us -> sv: ee -> re
+			for(Bitu i = 0; i < paging.kr_links.used; i++) {
+				Bitu tlb_index = paging.kr_links.entries[i];
+				Bitu lin_base = tlb_index << 12;
+				Bitu phys_page = paging.tlb.phys_page[tlb_index] & PHYSPAGE_ADDR;
+				PageHandler* handler = MEM_GetPageHandler(phys_page);
 
-	paging.tlb.phys_page[lin_page]=phys_page;
-	if (handler->flags & PFLAG_READABLE) paging.tlb.read[lin_page]=handler->GetHostReadPt(phys_page)-lin_base;
-	else paging.tlb.read[lin_page]=0;
-	paging.tlb.write[lin_page]=0;
+				paging.tlb.readhandler[tlb_index] = handler;
+				if (handler->flags&PFLAG_READABLE)
+					paging.tlb.read[tlb_index] = handler->GetHostReadPt(phys_page)-lin_base;
+				else paging.tlb.read[tlb_index] = 0;
+			}
+		}
+	} else { // WP=0
+		// ur
+		if (isUser) {
+			// sv -> us: rw -> re 
+			for(Bitu i = 0; i < paging.ur_links.used; i++) {
+				Bitu tlb_index = paging.ur_links.entries[i];
+				paging.tlb.writehandler[tlb_index] = &exception_handler;
+				paging.tlb.write[tlb_index] = 0;
+			}
+		} else {
+			// us -> sv: re -> rw
+			for(Bitu i = 0; i < paging.ur_links.used; i++) {
+				Bitu tlb_index = paging.ur_links.entries[i];
+				Bitu phys_page = paging.tlb.phys_page[tlb_index];
+				bool dirty = (phys_page & PHYSPAGE_DITRY)? true:false;
+				phys_page &= PHYSPAGE_ADDR;
+				PageHandler* handler = MEM_GetPageHandler(phys_page);
 
-	paging.links.entries[paging.links.used++]=lin_page;
-	paging.tlb.readhandler[lin_page]=handler;
-	paging.tlb.writehandler[lin_page]=&init_page_handler_userro;
+				if (dirty) {
+					Bitu lin_base = tlb_index << 12;
+					paging.tlb.writehandler[tlb_index] = handler;
+					if (handler->flags&PFLAG_WRITEABLE)
+						paging.tlb.write[tlb_index] = handler->GetHostWritePt(phys_page)-lin_base;
+					else paging.tlb.write[tlb_index] = 0;
+				} else {
+					paging.tlb.writehandler[tlb_index] = &foiling_handler;
+					paging.tlb.write[tlb_index] = 0;
+				}
+			}
+		}
+	}
 }
 
 #else
@@ -841,13 +1153,19 @@
 	paging.cr3=cr3;
 	
 	paging.base.page=cr3 >> 12;
-	paging.base.addr=cr3 & ~4095;
+	paging.base.addr=cr3 & ~0xFFF;
 //	LOG(LOG_PAGING,LOG_NORMAL)("CR3:%X Base %X",cr3,paging.base.page);
 	if (paging.enabled) {
 		PAGING_ClearTLB();
 	}
 }
 
+void PAGING_SetWP(bool wp) {
+	paging.wp = wp;
+	if (paging.enabled)
+		PAGING_ClearTLB();
+}
+
 void PAGING_Enable(bool enabled) {
 	/* If paging is disable we work from a default paging table */
 	if (paging.enabled==enabled) return;
@@ -874,6 +1192,7 @@
 	PAGING(Section* configuration):Module_base(configuration){
 		/* Setup default Page Directory, force it to update */
 		paging.enabled=false;
+		paging.wp=false;
 		PAGING_InitTLB();
 		Bitu i;
 		for (i=0;i<LINK_START;i++) {
Index: src/cpu/core_normal/prefix_0f.h
===================================================================
--- src/cpu/core_normal/prefix_0f.h	(revision 3720)
+++ src/cpu/core_normal/prefix_0f.h	(working copy)
@@ -144,7 +144,7 @@
 		break;
 	CASE_0F_B(0x08)												/* INVD */
 	CASE_0F_B(0x09)												/* WBINVD */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		if (cpu.pmode && cpu.cpl) EXCEPTION(EXCEPTION_GP);
 		break;
 	CASE_0F_B(0x20)												/* MOV Rd.CRx */
@@ -227,7 +227,7 @@
 		break;
 	CASE_0F_B(0x31)												/* RDTSC */
 		{
-			if (CPU_ArchitectureType<CPU_ARCHTYPE_PENTIUMSLOW) goto illegal_opcode;
+			if (CPU_ArchitectureType<CPU_ARCHTYPE_PENTIUM) goto illegal_opcode;
 			Bit64s tsc=(Bit64s)(PIC_FullIndex()*(double)CPU_CycleMax);
 			reg_edx=(Bit32u)(tsc>>32);
 			reg_eax=(Bit32u)(tsc&0xffffffff);
@@ -358,7 +358,7 @@
 		break;
 	CASE_0F_B(0xb0) 										/* cmpxchg Eb,Gb */
 		{
-			if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+			if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 			FillFlags();
 			GetRMrb;
 			if (rm >= 0xc0 ) {
@@ -386,7 +386,7 @@
 		}
 	CASE_0F_W(0xb1) 									/* cmpxchg Ew,Gw */
 		{
-			if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+			if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 			FillFlags();
 			GetRMrw;
 			if (rm >= 0xc0 ) {
@@ -574,7 +574,7 @@
 		}
 	CASE_0F_B(0xc0)												/* XADD Gb,Eb */
 		{
-			if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+			if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 			GetRMrb;Bit8u oldrmrb=*rmrb;
 			if (rm >= 0xc0 ) {GetEArb;*rmrb=*earb;*earb+=oldrmrb;}
 			else {GetEAa;*rmrb=LoadMb(eaa);SaveMb(eaa,LoadMb(eaa)+oldrmrb);}
@@ -582,34 +582,34 @@
 		}
 	CASE_0F_W(0xc1)												/* XADD Gw,Ew */
 		{
-			if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+			if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 			GetRMrw;Bit16u oldrmrw=*rmrw;
 			if (rm >= 0xc0 ) {GetEArw;*rmrw=*earw;*earw+=oldrmrw;}
 			else {GetEAa;*rmrw=LoadMw(eaa);SaveMw(eaa,LoadMw(eaa)+oldrmrw);}
 			break;
 		}
 	CASE_0F_W(0xc8)												/* BSWAP AX */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPW(reg_ax);break;
 	CASE_0F_W(0xc9)												/* BSWAP CX */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPW(reg_cx);break;
 	CASE_0F_W(0xca)												/* BSWAP DX */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPW(reg_dx);break;
 	CASE_0F_W(0xcb)												/* BSWAP BX */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPW(reg_bx);break;
 	CASE_0F_W(0xcc)												/* BSWAP SP */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPW(reg_sp);break;
 	CASE_0F_W(0xcd)												/* BSWAP BP */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPW(reg_bp);break;
 	CASE_0F_W(0xce)												/* BSWAP SI */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPW(reg_si);break;
 	CASE_0F_W(0xcf)												/* BSWAP DI */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPW(reg_di);break;
 		
Index: src/cpu/core_normal/prefix_66_0f.h
===================================================================
--- src/cpu/core_normal/prefix_66_0f.h	(revision 3720)
+++ src/cpu/core_normal/prefix_66_0f.h	(working copy)
@@ -237,7 +237,7 @@
 		}
 	CASE_0F_D(0xb1)												/* CMPXCHG Ed,Gd */
 		{	
-			if (CPU_ArchitectureType<CPU_ARCHTYPE_486NEWSLOW) goto illegal_opcode;
+			if (CPU_ArchitectureType<CPU_ARCHTYPE_486NEW) goto illegal_opcode;
 			FillFlags();
 			GetRMrd;
 			if (rm >= 0xc0) {
@@ -433,33 +433,33 @@
 		}
 	CASE_0F_D(0xc1)												/* XADD Gd,Ed */
 		{
-			if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+			if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 			GetRMrd;Bit32u oldrmrd=*rmrd;
 			if (rm >= 0xc0 ) {GetEArd;*rmrd=*eard;*eard+=oldrmrd;}
 			else {GetEAa;*rmrd=LoadMd(eaa);SaveMd(eaa,LoadMd(eaa)+oldrmrd);}
 			break;
 		}
 	CASE_0F_D(0xc8)												/* BSWAP EAX */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPD(reg_eax);break;
 	CASE_0F_D(0xc9)												/* BSWAP ECX */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPD(reg_ecx);break;
 	CASE_0F_D(0xca)												/* BSWAP EDX */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPD(reg_edx);break;
 	CASE_0F_D(0xcb)												/* BSWAP EBX */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPD(reg_ebx);break;
 	CASE_0F_D(0xcc)												/* BSWAP ESP */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPD(reg_esp);break;
 	CASE_0F_D(0xcd)												/* BSWAP EBP */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPD(reg_ebp);break;
 	CASE_0F_D(0xce)												/* BSWAP ESI */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPD(reg_esi);break;
 	CASE_0F_D(0xcf)												/* BSWAP EDI */
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegal_opcode;
 		BSWAPD(reg_edi);break;
Index: src/cpu/core_dyn_x86/decoder.h
===================================================================
--- src/cpu/core_dyn_x86/decoder.h	(revision 3720)
+++ src/cpu/core_dyn_x86/decoder.h	(working copy)
@@ -61,22 +61,13 @@
 		return false;
 	}
 	if (handler->flags & PFLAG_NOCODE) {
-		if (PAGING_ForcePageInit(lin_addr)) {
-			handler=get_tlb_readhandler(lin_addr);
-			if (handler->flags & PFLAG_HASCODE) {
-				cph=( CodePageHandler *)handler;
-				return false;
-			}
-		}
-		if (handler->flags & PFLAG_NOCODE) {
-			LOG_MSG("DYNX86:Can't run code in this page!");
-			cph=0;		return false;
-		}
+		LOG_MSG("DYNX86:Can't run code in this page!");
+		cph=0;		return false;
 	} 
 	Bitu lin_page=lin_addr >> 12;
 	Bitu phys_page=lin_page;
 	if (!PAGING_MakePhysPage(phys_page)) {
-		LOG_MSG("DYNX86:Can't find physpage");
+		LOG_MSG("DYNX86:Can't find physpage for lin addr %x", lin_addr);
 		cph=0;		return false;
 	}
 	/* Find a free CodePage */
Index: src/cpu/cpu.cpp
===================================================================
--- src/cpu/cpu.cpp	(revision 3720)
+++ src/cpu/cpu.cpp	(working copy)
@@ -129,7 +129,7 @@
 	Bit32u* data = (Bit32u*)&saved;
 	mem_writed(address,*data);
 	mem_writed(address+4,*(data+1));
-	cpu.mpl=03;
+	cpu.mpl=3;
 }
 
 
@@ -167,6 +167,15 @@
 	}
 }
 
+void CPU_SetCPL(Bitu newcpl) {
+	if (newcpl != cpu.cpl) {
+		if (paging.enabled) {
+			if ( ((cpu.cpl < 3) && (newcpl == 3)) || ((cpu.cpl == 3) && (newcpl < 3)) )
+			PAGING_SwitchCPL(newcpl == 3);
+		}
+		cpu.cpl = newcpl;
+	}
+}
 
 void CPU_SetFlags(Bitu word,Bitu mask) {
 	mask|=CPU_extflags_toggle;	// ID-flag and AC-flag can be toggled on CPUID-supporting CPUs
@@ -449,7 +458,10 @@
 	} else {
 	
 		/* Setup the new cr3 */
-		PAGING_SetDirBase(new_cr3);
+		if (paging.cr3 != new_cr3)
+			// if they are the same it is not flushed
+			// according to the 386 manual
+			PAGING_SetDirBase(new_cr3);
 
 		/* Load new context */
 		if (new_tss.is386) {
@@ -473,13 +485,13 @@
 	if (reg_flags & FLAG_VM) {
 		SegSet16(cs,new_cs);
 		cpu.code.big=false;
-		cpu.cpl=3;			//We don't have segment caches so this will do
+		CPU_SetCPL(3);			//We don't have segment caches so this will do
 	} else {
 		/* Protected mode task */
 		if (new_ldt!=0) CPU_LLDT(new_ldt);
 		/* Load the new CS*/
 		Descriptor cs_desc;
-		cpu.cpl=new_cs & 3;
+		CPU_SetCPL(new_cs & 3);
 		if (!cpu.gdt.GetDescriptor(new_cs,cs_desc))
 			E_Exit("Task switch with CS beyond limits");
 		if (!cs_desc.saved.seg.p)
@@ -676,7 +688,7 @@
 							reg_sp=n_esp & 0xffff;
 						}
 
-						cpu.cpl=cs_dpl;
+						CPU_SetCPL(cs_dpl);
 						if (gate.Type() & 0x8) {	/* 32-bit Gate */
 							if (reg_flags & FLAG_VM) {
 								CPU_Push32(SegValue(gs));SegSet16(gs,0x0);
@@ -846,7 +858,7 @@
 
 				CPU_SetFlags(n_flags,FMASK_ALL | FLAG_VM);
 				DestroyConditionFlags();
-				cpu.cpl=3;
+				CPU_SetCPL(3);
 
 				CPU_SetSegGeneral(ss,n_ss);
 				CPU_SetSegGeneral(es,n_es);
@@ -967,7 +979,7 @@
 			CPU_SetFlags(n_flags,mask);
 			DestroyConditionFlags();
 
-			cpu.cpl=n_cs_rpl;
+			CPU_SetCPL(n_cs_rpl);
 			reg_eip=n_eip;
 
 			Segs.val[ss]=n_ss;
@@ -1216,7 +1228,7 @@
 							reg_sp=n_esp & 0xffff;
 						}
 
-						cpu.cpl = n_cs_desc.DPL();
+						CPU_SetCPL(n_cs_desc.DPL());
 						Bit16u oldcs    = SegValue(cs);
 						/* Switch to new CS:EIP */
 						Segs.phys[cs]	= n_cs_desc.GetBase();
@@ -1439,7 +1451,7 @@
 				"RET:Stack segment not present",
 				EXCEPTION_SS,n_ss & 0xfffc)
 
-			cpu.cpl = rpl;
+			CPU_SetCPL(rpl);
 			Segs.phys[cs]=desc.GetBase();
 			cpu.code.big=desc.Big()>0;
 			Segs.val[cs]=(selector&0xfffc) | cpu.cpl;
@@ -1549,11 +1561,15 @@
 			value|=CR0_FPUPRESENT;
 			Bitu changed=cpu.cr0 ^ value;
 			if (!changed) return;
+			if (GCC_UNLIKELY(changed & CR0_WRITEPROTECT)) {
+				if (CPU_ArchitectureType >= CPU_ARCHTYPE_486OLD)
+					PAGING_SetWP((value&CR0_WRITEPROTECT)? true:false);
+			}
 			cpu.cr0=value;
 			if (value & CR0_PROTECTION) {
 				cpu.pmode=true;
 				LOG(LOG_CPU,LOG_NORMAL)("Protected mode");
-				PAGING_Enable((value & CR0_PAGING)>0);
+				PAGING_Enable((value&CR0_PAGING)? true:false);
 
 				if (!(CPU_AutoDetermineMode&CPU_AUTODETERMINE_MASK)) break;
 
@@ -1606,7 +1622,7 @@
 	/* Check if privileged to access control registers */
 	if (cpu.pmode && (cpu.cpl>0)) return CPU_PrepareException(EXCEPTION_GP,0);
 	if ((cr==1) || (cr>4)) return CPU_PrepareException(EXCEPTION_UD,0);
-	if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) {
+	if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) {
 		if (cr==4) return CPU_PrepareException(EXCEPTION_UD,0);
 	}
 	CPU_SET_CRX(cr,value);
@@ -1616,8 +1632,8 @@
 Bitu CPU_GET_CRX(Bitu cr) {
 	switch (cr) {
 	case 0:
-		if (CPU_ArchitectureType>=CPU_ARCHTYPE_PENTIUMSLOW) return cpu.cr0;
-		else if (CPU_ArchitectureType>=CPU_ARCHTYPE_486OLDSLOW) return (cpu.cr0 & 0xe005003f);
+		if (CPU_ArchitectureType>=CPU_ARCHTYPE_PENTIUM) return cpu.cr0;
+		else if (CPU_ArchitectureType>=CPU_ARCHTYPE_486OLD) return (cpu.cr0 & 0xe005003f);
 		else return (cpu.cr0 | 0x7ffffff0);
 	case 2:
 		return paging.cr2;
@@ -1655,7 +1671,7 @@
 		break;
 	case 5:
 	case 7:
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_PENTIUMSLOW) {
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_PENTIUM) {
 			cpu.drx[7]=(value|0x400) & 0xffff2fff;
 		} else {
 			cpu.drx[7]=(value|0x400);
@@ -2008,7 +2024,7 @@
 }
 
 bool CPU_CPUID(void) {
-	if (CPU_ArchitectureType<CPU_ARCHTYPE_486NEWSLOW) return false;
+	if (CPU_ArchitectureType<CPU_ARCHTYPE_486NEW) return false;
 	switch (reg_eax) {
 	case 0:	/* Vendor ID String and maximum level? */
 		reg_eax=1;  /* Maximum level */ 
@@ -2017,13 +2033,13 @@
 		reg_ecx='n' | ('t' << 8) | ('e' << 16) | ('l'<< 24); 
 		break;
 	case 1:	/* get processor type/family/model/stepping and feature flags */
-		if ((CPU_ArchitectureType==CPU_ARCHTYPE_486NEWSLOW) ||
+		if ((CPU_ArchitectureType==CPU_ARCHTYPE_486NEW) ||
 			(CPU_ArchitectureType==CPU_ARCHTYPE_MIXED)) {
 			reg_eax=0x402;		/* intel 486dx */
 			reg_ebx=0;			/* Not Supported */
 			reg_ecx=0;			/* No features */
 			reg_edx=0x00000001;	/* FPU */
-		} else if (CPU_ArchitectureType==CPU_ARCHTYPE_PENTIUMSLOW) {
+		} else if (CPU_ArchitectureType==CPU_ARCHTYPE_PENTIUM) {
 			reg_eax=0x513;		/* intel pentium */
 			reg_ebx=0;			/* Not Supported */
 			reg_ecx=0;			/* No features */
@@ -2210,7 +2226,7 @@
 			cpu.drx[i]=0;
 			cpu.trx[i]=0;
 		}
-		if (CPU_ArchitectureType==CPU_ARCHTYPE_PENTIUMSLOW) {
+		if (CPU_ArchitectureType==CPU_ARCHTYPE_PENTIUM) {
 			cpu.drx[6]=0xffff0ff0;
 		} else {
 			cpu.drx[6]=0xffff1ff0;
@@ -2356,9 +2372,9 @@
 		if (cputype == "auto") {
 			CPU_ArchitectureType = CPU_ARCHTYPE_MIXED;
 		} else if (cputype == "386") {
-			CPU_ArchitectureType = CPU_ARCHTYPE_386FAST;
+			CPU_ArchitectureType = CPU_ARCHTYPE_386;
 		} else if (cputype == "386_prefetch") {
-			CPU_ArchitectureType = CPU_ARCHTYPE_386FAST;
+			CPU_ArchitectureType = CPU_ARCHTYPE_386;
 			if (core == "normal") {
 				cpudecoder=&CPU_Core_Prefetch_Run;
 				CPU_PrefetchQueueSize = 16;
@@ -2369,12 +2385,10 @@
 			} else {
 				E_Exit("prefetch queue emulation requires the normal core setting.");
 			}
-		} else if (cputype == "386_slow") {
-			CPU_ArchitectureType = CPU_ARCHTYPE_386SLOW;
-		} else if (cputype == "486_slow") {
-			CPU_ArchitectureType = CPU_ARCHTYPE_486NEWSLOW;
+		} else if (cputype == "486") {
+			CPU_ArchitectureType = CPU_ARCHTYPE_486NEW;
 		} else if (cputype == "486_prefetch") {
-			CPU_ArchitectureType = CPU_ARCHTYPE_486NEWSLOW;
+			CPU_ArchitectureType = CPU_ARCHTYPE_486NEW;
 			if (core == "normal") {
 				cpudecoder=&CPU_Core_Prefetch_Run;
 				CPU_PrefetchQueueSize = 32;
@@ -2385,12 +2399,12 @@
 			} else {
 				E_Exit("prefetch queue emulation requires the normal core setting.");
 			}
-		} else if (cputype == "pentium_slow") {
-			CPU_ArchitectureType = CPU_ARCHTYPE_PENTIUMSLOW;
+		} else if (cputype == "pentium") {
+			CPU_ArchitectureType = CPU_ARCHTYPE_PENTIUM;
 		}
 
-		if (CPU_ArchitectureType>=CPU_ARCHTYPE_486NEWSLOW) CPU_extflags_toggle=(FLAG_ID|FLAG_AC);
-		else if (CPU_ArchitectureType>=CPU_ARCHTYPE_486OLDSLOW) CPU_extflags_toggle=(FLAG_AC);
+		if (CPU_ArchitectureType>=CPU_ARCHTYPE_486NEW) CPU_extflags_toggle=(FLAG_ID|FLAG_AC);
+		else if (CPU_ArchitectureType>=CPU_ARCHTYPE_486OLD) CPU_extflags_toggle=(FLAG_AC);
 		else CPU_extflags_toggle=0;
 
 
Index: src/cpu/core_full/op.h
===================================================================
--- src/cpu/core_full/op.h	(revision 3720)
+++ src/cpu/core_full/op.h	(working copy)
@@ -603,15 +603,15 @@
 		inst_op1_d&=~(1 << (inst_op2_d & 31));
 		break;
 	case O_BSWAPw:
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegalopcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegalopcode;
 		BSWAPW(inst_op1_w);
 		break;
 	case O_BSWAPd:
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegalopcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLD) goto illegalopcode;
 		BSWAPD(inst_op1_d);
 		break;
 	case O_CMPXCHG:
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_486NEWSLOW) goto illegalopcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_486NEW) goto illegalopcode;
 		FillFlags();
 		if (inst_op1_d==reg_eax) {
 			inst_op1_d=reg_32(inst.rm_index);
Index: src/cpu/core_full/load.h
===================================================================
--- src/cpu/core_full/load.h	(revision 3720)
+++ src/cpu/core_full/load.h	(working copy)
@@ -501,7 +501,7 @@
 		CPU_SW_Interrupt_NoIOPLCheck(1,GetIP());
 		continue;
 	case D_RDTSC: {
-		if (CPU_ArchitectureType<CPU_ARCHTYPE_PENTIUMSLOW) goto illegalopcode;
+		if (CPU_ArchitectureType<CPU_ARCHTYPE_PENTIUM) goto illegalopcode;
 		Bit64s tsc=(Bit64s)(PIC_FullIndex()*(double)CPU_CycleMax);
 		reg_edx=(Bit32u)(tsc>>32);
 		reg_eax=(Bit32u)(tsc&0xffffffff);
Index: src/dosbox.cpp
===================================================================
--- src/dosbox.cpp	(revision 3720)
+++ src/dosbox.cpp	(working copy)
@@ -406,12 +406,11 @@
 	Pstring->Set_help("CPU Core used in emulation. auto will switch to dynamic if available and\n"
 		"appropriate.");
 
-	const char* cputype_values[] = { "auto", "386", "386_slow", "486_slow", "pentium_slow", "386_prefetch", 0};
-	Pstring = secprop->Add_string("cputype",Property::Changeable::Always,"auto");
+	const char* cputype_values[] = {"auto", "386", "486", "pentium", "386_prefetch", 0};
+	Pstring = secprop->Add_string("cputype",Property::Changeable::Always, "auto");
 	Pstring->Set_values(cputype_values);
-	Pstring->Set_help("CPU Type used in emulation. auto is the fastest choice.");
+	Pstring->Set_help("CPU Type used in emulation. auto emulates a 486 which tolerates Pentium instructions.");
 
-
 	Pmulti_remain = secprop->Add_multiremain("cycles",Property::Changeable::Always," ");
 	Pmulti_remain->Set_help(
 		"Amount of instructions DOSBox tries to emulate each millisecond.\n"
